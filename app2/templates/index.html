<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Driftville</title>
  <style>
    body { font-family: "Press Start 2P", "Inter", -apple-system, sans-serif; margin:0; padding:0; background: radial-gradient(circle at 20% 20%, #1c2541, #0b132b); color:#f8f9ff; }
    header { padding: 18px 24px; background: rgba(255,255,255,0.06); box-shadow: 0 10px 25px rgba(0,0,0,0.25); position: sticky; top:0; z-index:2; display:flex; align-items:center; justify-content:space-between; gap:16px; }
    h1 { margin:0; font-size: 18px; letter-spacing: 1px; }
    #time-controls { display:flex; align-items:center; gap:10px; background: rgba(255,255,255,0.08); border:1px solid rgba(111,255,233,0.4); border-radius:14px; padding:6px 10px; box-shadow: 0 8px 18px rgba(0,0,0,0.2); }
    #time-controls button { background:#10243a; color:#6fffe9; border:1px solid rgba(111,255,233,0.4); border-radius:10px; padding:6px 10px; font-weight:700; box-shadow:none; }
    #time-controls button:hover { transform:none; border-color:#6fffe9; }
    #time-slider { width:160px; accent-color:#6fffe9; }
    #time-label { min-width:48px; text-align:right; font-weight:700; letter-spacing:0.5px; color:#6fffe9; }
    #date-label { min-width:98px; text-align:right; font-weight:700; letter-spacing:0.5px; color:#9fb3c8; }
    .panel { padding: 16px 24px; }
    button { background:#6fffe9; color:#0b132b; border:none; border-radius:10px; padding:10px 14px; font-weight:700; cursor:pointer; box-shadow: 0 8px 20px rgba(111,255,233,0.4); }
    button:hover { transform: translateY(-1px); }
    .grid { display:grid; grid-template-columns: repeat(auto-fill, minmax(170px,1fr)); gap:12px; transition: height 0.3s ease, opacity 0.3s ease; }
    .card { background: linear-gradient(135deg, #0d1b2a 0%, #1b263b 100%); border:1px solid rgba(111,255,233,0.3); border-radius:14px; padding:12px; box-shadow: 0 10px 25px rgba(0,0,0,0.35); cursor:pointer; min-height:118px; display:flex; flex-direction:column; justify-content:center; gap:6px; }
    .card:hover { border-color:#6fffe9; }
    .emoji { font-size:32px; }
    .duo { display:flex; gap:6px; align-items:center; }
    .name { margin-top:6px; font-weight:700; }
    .muted { color:#9fb3c8; font-size:11px; margin-top:2px; }
    .arcade-label { font-weight:900; font-size:13px; letter-spacing:1px; color:#6fffe9; text-transform:uppercase; text-shadow: 1px 1px 0 #0b132b, 2px 2px 0 #0b132b; }
    .hidden { opacity:0; pointer-events:none; transition: opacity 0.25s ease; }
    #floorplan { margin-top:16px; padding:14px; background: rgba(255,255,255,0.04); border:1px solid rgba(111,255,233,0.25); border-radius:12px; }
    .town { display:flex; justify-content:center; gap:10px; min-height:260px; align-items:center; flex-wrap:wrap; padding:8px 0; transition: min-height 0.25s ease, max-height 0.25s ease; }
    .tile { width:320px; height:250px; background: linear-gradient(135deg, #0f1f3a 0%, #16294d 100%); border:1px dashed rgba(111,255,233,0.4); border-radius:16px; padding:16px; text-align:center; color:#f8f9ff; display:flex; flex-direction:column; align-items:center; justify-content:center; box-sizing:border-box; gap:8px; }
    .tile .emoji { font-size:24px; }
    .faded { opacity: 0.35; transition: opacity 0.25s ease; pointer-events: none; }
    .placeholder { border:1px dashed rgba(111,255,233,0.3); background: rgba(255,255,255,0.02); color:#9fb3c8; }
    .centered { display:flex; flex-direction:column; align-items:center; text-align:center; }
    #restart { background: transparent; box-shadow:none; color:#6fffe9; border:1px solid rgba(111,255,233,0.5); border-radius:8px; height:28px; display:none; align-items:center; justify-content:center; padding:0 8px; font-size:14px; text-transform:uppercase; letter-spacing:0.5px; gap:4px; }
    #restart:hover { transform:none; box-shadow: none; }
    /* Floorplan */
    #floorplan-map { margin-top:12px; background: rgba(255,255,255,0.03); border:1px solid rgba(111,255,233,0.25); border-radius:12px; padding:12px; display:none; }
    #map-grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap:10px; }
    .cell { position:relative; border:1px dashed rgba(111,255,233,0.3); border-radius:10px; min-height:120px; padding:8px; color:#9fb3c8; box-sizing:border-box; background: rgba(255,255,255,0.02); }
    .cell-label { font-size:12px; margin-bottom:6px; font-weight:700; color:#6fffe9; }
    .children { font-size:11px; line-height:1.4; color:#b8c7d9; }
    .token-tray { display:flex; flex-wrap:wrap; gap:6px; justify-content:flex-end; margin-top:auto; }
    .cell { display:flex; flex-direction:column; gap:8px; }
    .token { padding:6px 12px; border-radius:999px; font-size:12px; color:#0b132b; font-weight:700; background:#6fffe9; box-shadow: 0 6px 14px rgba(0,0,0,0.15); white-space:nowrap; }
    .child-grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap:6px; margin-top:4px; }
    .subcell { min-height:60px; min-width:max-content; border:1px dashed rgba(111,255,233,0.25); border-radius:8px; padding:6px; background: rgba(255,255,255,0.01); display:flex; flex-direction:column; gap:6px; }
    .subcell-label { font-size:11px; font-weight:700; color:#6fffe9; }
    /* Sections */
    .section { margin-top:18px; border:1px solid rgba(111,255,233,0.25); border-radius:12px; background: rgba(255,255,255,0.02); overflow:hidden; }
    .section-header { display:flex; align-items:center; justify-content:space-between; padding:12px 14px; cursor:pointer; }
    .section-header:hover { background: rgba(255,255,255,0.02); }
    .section-title { font-weight:800; letter-spacing:0.5px; color:#6fffe9; }
    .section-toggle { color:#9fb3c8; font-size:12px; letter-spacing:0.4px; }
    .section-body { padding:12px 14px; display:block; }
    .section-body.collapsed { display:none; }
    .section-grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); gap:12px; }
    /* Section cards inside Schedules/Bios/Feedback panels */
    .section-card { background: rgba(255,255,255,0.02); border:1px dashed rgba(111,255,233,0.3); border-radius:10px; padding:12px; color:#e8f4ff; font-family: "Inter", -apple-system, sans-serif; }
    .section-card * { font-family: "Inter", -apple-system, sans-serif; }
    .section-card h4 { margin:0 0 8px 0; color:#6fffe9; font-size:14px; letter-spacing:0.4px; }
    .chip { display:inline-flex; align-items:center; gap:6px; padding:6px 10px; margin:0 0 10px 0; border-radius:999px; background: rgba(111,255,233,0.12); border:1px solid rgba(111,255,233,0.25); color:#e8f4ff; font-size:12px; font-family: "Inter", -apple-system, sans-serif; }
    .small-muted { color:#9fb3c8; font-size:11px; }
    .mono { font-family: "Inter", -apple-system, sans-serif; font-size:12px; }
    /* Current state row */
    .state-row { margin-top:16px; border:1px solid #e6dcb5; border-radius:12px; background:#fdf6e3; padding:0; color:#1f2d3d; overflow:hidden; }
    .state-row .section-header { padding:12px 14px; }
    .state-grid { display:flex; flex-direction:column; gap:10px; padding:0 14px 12px 14px; }
    .row-grid { display:grid; grid-template-columns: repeat(5, minmax(220px, 1fr)); gap:6px; width:100%; }
    .row-box { position:relative; border:1px dashed #d8c9a2; border-radius:10px; padding:8px; color:#1f2d3d; background:#fffaf0; min-height:110px; display:flex; flex-direction:column; gap:2px; }
    .row-title { font-weight:700; color:#0f172a; margin:0 0 4px 0; font-size:12px; letter-spacing:0.3px; }
    .row-box .label { font-weight:700; color:#4b5563; font-size:11px; }
    .row-box .line { margin:1px 0; font-size:12px; color:#1f2937; }
    .row-box.distract .row-title { color:#2563eb; }
    .action-badge { position:absolute; top:6px; right:6px; display:inline-flex; align-items:center; justify-content:center; font-size:36px; line-height:1; padding:8px 10px; background:#fdf6e3; color:#0f172a; border-radius:10px; box-shadow:0 4px 10px rgba(0,0,0,0.08); }
    .orpa-cell { background:#eef2f7; border-color:#cbd5e1; }
    .orpa-cell .line { color:#0f172a; }
    .orpda-cell { background:#e7f4eb; border-color:#b6dec1; }
    .orpda-cell .line { color:#0f172a; }
    .header-cell { min-height:44px; padding:6px 8px; display:flex; align-items:center; justify-content:flex-start; background:transparent; border:none; border-radius:10px; color:#0f172a; font-weight:800; }
    .header-cell.orpa-cell { background:transparent; border:none; color:#0f172a; }
    .header-badge { display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border-radius:999px; background:#2a3a52; color:#fdf6e3; font-size:12px; }
    .header-badge.orpa-cell { background:#d9e2ec; color:#0f172a; }
    .header-badge.orpda-cell { background:#cfe7d6; color:#0f172a; }
    .no-data { display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border-radius:999px; background:#e5e7eb; color:#374151; font-weight:700; font-size:12px; }
    .metrics-row { display:flex; flex-wrap:wrap; gap:8px; padding:8px 14px 2px 14px; align-items:center; }
    .metric-badge { display:inline-flex; align-items:center; gap:4px; padding:6px 10px; border-radius:999px; background:#e9d8af; color:#111827; font-weight:700; font-size:12px; }
    .metric-label { color:#4b5563; font-weight:700; }
    .metrics-section { margin-top:16px; border:1px solid #e6dcb5; border-radius:12px; background:#fdf6e3; padding:12px; color:#1f2d3d; }
    .metrics-grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap:10px; }
    .metric-card { background:#fffaf0; border:1px dashed #d8c9a2; border-radius:10px; padding:8px; }
    .metric-title { font-weight:700; color:#0f172a; margin-bottom:4px; }
    .metric-gauge-track { width:100%; height:10px; background:#e5e7eb; border-radius:999px; overflow:hidden; }
    .metric-gauge-fill { height:100%; border-radius:999px; }
    .metric-gauge-label { font-size:12px; color:#111827; margin-bottom:4px; display:flex; justify-content:space-between; }
    .chipline { display:flex; flex-wrap:wrap; gap:6px; margin-top:0; }
    .metric-label.inline { display:inline-flex; align-items:center; margin-right:6px; }
    .chipline .metric-badge { background:#e5e7eb; }
    .feedback-box textarea { background:#0d1f34; border:1px solid rgba(111,255,233,0.25); border-radius:8px; color:#e8f4ff; padding:6px; width:100%; min-height:70px; }
    .feedback-box select { background:#0d1f34; border:1px solid rgba(111,255,233,0.25); border-radius:8px; color:#e8f4ff; padding:4px 6px; width:100%; }
    .feedback-box .actions { display:flex; gap:6px; align-items:center; margin-top:6px; }
    .yaml-overlay { position:fixed; inset:0; background:rgba(255,255,255,0.65); display:none; align-items:center; justify-content:center; z-index:99; }
    .yaml-dialog { background:#ffffff; border:1px solid #e5e7eb; border-radius:12px; width:90%; max-width:720px; max-height:80vh; display:flex; flex-direction:column; box-shadow:0 18px 36px rgba(0,0,0,0.12); }
    .yaml-header { display:flex; justify-content:space-between; align-items:center; padding:10px 12px; border-bottom:1px solid #e5e7eb; color:#111827; }
    .yaml-body { padding:10px 12px; overflow:auto; background:#f9fafb; font-family: "Inter"}
    .yaml-body pre { white-space:pre-wrap; color:#111827; margin:0; font-size:12px; line-height:1.5; font-family: "Inter", -apple-system, sans-serif}
    .yaml-close { background:#ffffff; color:#111827; border:1px solid #d1d5db; border-radius:8px; padding:4px 8px; cursor:pointer; }
  </style>
</head>
<body>
  <header>
    <h1>Driftville</h1>
    <div id="time-controls">
      <button id="time-minus">-15m</button>
      <input type="range" id="time-slider" min="0" max="1439" step="15" />
      <button id="time-plus">+15m</button>
      <div id="time-label">--:--</div>
      <div id="date-label">--</div>
    </div>
  </header>
  <div class="panel">
    <div class="grid" id="grid"></div>

    <div id="floorplan">
      <div id="floor-top" class="centered" style="position:relative;">
        <button id="restart" title="Restart" style="position:absolute; left:0; top:-6px;">‚Üê RESTART</button>
        <div class="muted arcade-label" id="town-label" style="margin-bottom:6px; text-align:center;">Select one persona</div>
      </div>
      <div class="town" id="town"></div>
      <div id="floor-bottom" style="margin-top:10px; display:flex; justify-content:center;">
        <button id="simulate" style="min-width:320px;">Simulate</button>
      </div>
      <div id="floorplan-map">
        <div class="muted" style="margin-bottom:6px;">Driftville Town</div>
        <div id="map-grid"></div>
      </div>
    </div>

    <div class="metrics-section" id="metrics-section" style="display:none;">
      <div id="metrics-body"></div>
    </div>

    <div class="state-row" id="state-row" style="display:none;">
    <div class="state-grid" id="state-grid"></div>
    </div>

    <div class="section" id="schedules-section">
      <div class="section-header" data-target="schedules-body">
        <div class="section-title">Schedules</div>
        <div class="section-toggle" id="schedules-toggle">Collapse</div>
      </div>
      <div class="section-body" id="schedules-body">
        <div id="schedules-grid" class="section-grid"></div>
      </div>
    </div>

    <div class="section" id="bios-section">
      <div class="section-header" data-target="bios-body">
        <div class="section-title">Bios</div>
        <div class="section-toggle" id="bios-toggle">Collapse</div>
      </div>
      <div class="section-body" id="bios-body">
        <div id="bios-grid" class="section-grid"></div>
      </div>
    </div>

    <div class="section" id="feedback-section">
      <div class="section-header" data-target="feedback-body">
        <div class="section-title">Layer Feedback</div>
        <div class="section-toggle" id="feedback-toggle">Collapse</div>
      </div>
      <div class="section-body" id="feedback-body">
        <div class="small-muted" id="feedback-status">Loading feedback...</div>
        <div id="feedback-list" class="section-grid" style="grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));"></div>
      </div>
    </div>
  </div>

  <div class="yaml-overlay" id="yaml-overlay">
    <div class="yaml-dialog">
      <div class="yaml-header">
        <div>Layer YAML</div>
        <button class="yaml-close" id="yaml-close">Close</button>
      </div>
      <div class="yaml-body">
        <pre id="yaml-content">No data.</pre>
      </div>
    </div>
  </div>

  <script>
    (function() {
    const showError = (err) => {
      console.error(err);
      const box = document.createElement("pre");
      box.style.background = "#2b1b2f";
      box.style.color = "#ffd1dc";
      box.style.padding = "12px";
      box.style.margin = "12px";
      box.style.border = "1px solid #ff8ccf";
      box.textContent = `UI error: ${err && err.message ? err.message : err}`;
      document.body.prepend(box);
    };
    try {
    const personas = {{ personas | tojson | safe }};
    const emojiMap = {{ emoji_map | tojson | safe }};
    const faceMap = {{ face_map | tojson | safe }};
    const sessionData = {{ session_data | tojson | safe }};
    const orpdaSessions = sessionData.orpda || {};
    const orpaSessions = sessionData.orpa || {};
    const showEval = {{ show_eval | tojson | safe }};
    const metricsByName = {};
    const personaByName = Object.fromEntries(personas.map(p => [p.name, p]));
    const scheduleByName = Object.fromEntries(personas.map(p => [p.name, p.schedule || []]));
    const sessionsByName = sessionData || {};
    const badgePalette = ["#6fffe9", "#ffd166"];
    const badgeColors = {};
    const colorFor = (name) => {
      if (badgeColors[name]) return badgeColors[name];
      const idx = Object.keys(badgeColors).length % badgePalette.length;
      badgeColors[name] = badgePalette[idx];
      return badgeColors[name];
    };
    const grid = document.getElementById("grid");
    const town = document.getElementById("town");
    const townLabel = document.getElementById("town-label");
    const floorTop = document.getElementById("floor-top");
    const floorBottom = document.getElementById("floor-bottom");
    const simBtn = document.getElementById("simulate");
    const restartBtn = document.getElementById("restart");
    const chosen = []; // names added to Driftville (max 2)
    let simLocked = false;
    const floorplanMap = document.getElementById("floorplan-map");
    const mapGrid = document.getElementById("map-grid");
    let mapLayout = [];
    let mapIds = new Set();
    const schedulesSection = document.getElementById("schedules-section");
    const biosSection = document.getElementById("bios-section");
    const schedulesGrid = document.getElementById("schedules-grid");
    const biosGrid = document.getElementById("bios-grid");
    const stateGrid = document.getElementById("state-grid");
    const minutesNow = () => {
      const d = new Date();
      return d.getHours() * 60 + d.getMinutes();
    };
      const actionEmoji = (action) => {
        if (!action) return "üîÑ";
        const a = action.toLowerCase();
        if (a.includes("eat") || a.includes("breakfast") || a.includes("lunch") || a.includes("dinner")) return "üçΩÔ∏è";
      if (a.includes("commute") || a.includes("drive") || a.includes("travel")) return "üöó";
      if (a.includes("morning") || a.includes("routine")) return "üöø";
      if (a.includes("work") || a.includes("office")) return "üíª";
      if (a.includes("teach") || a.includes("class")) return "üéì";
      if (a.includes("shop")) return "üõí";
      if (a.includes("sleep") || a.includes("nap")) return "üò¥";
      if (a.includes("meet")) return "ü§ù";
      if (a.includes("exercise") || a.includes("run") || a.includes("gym")) return "üèÉ";
      if (a.includes("read") || a.includes("book")) return "üìñ";
      if (a.includes("cook") || a.includes("bake")) return "üç≥";
      if (a.includes("study")) return "üìö";
      if (a.includes("clean") || a.includes("tidy")) return "üßπ";
      if (a.includes("write")) return "‚úçÔ∏è";
      if (a.includes("social") || a.includes("chat") || a.includes("talk")) return "üó£Ô∏è";
      return "üîÑ";
    };
    const clampMinute = (m) => Math.min(1439, Math.max(0, m));
    const fmtTime = (m) => {
      const hh = String(Math.floor(m / 60)).padStart(2, "0");
      const mm = String(m % 60).padStart(2, "0");
      return `${hh}:${mm}`;
    };
    const minsFromDt = (dt) => {
      if (!dt) return null;
      const parts = dt.split(" ");
      const hm = parts[1] || dt;
      const [h, m] = hm.split(":").map(Number);
      if (Number.isFinite(h) && Number.isFinite(m)) return h * 60 + m;
      return null;
    };
    const stopWords = new Set(["the","and","for","with","from","this","that","about","into","over","into","while","her","his","him","she","him","they","them","their","our","ours","your","yours","will","none","null","true","false","just","new"]);
    const avgScore = (arr) => arr.length ? arr.reduce((a,b)=>a+b,0) / arr.length : 0;
    const modeMap = {
      aligned: 1, partial: 0.5, off_track: 0,
      stable: 1, slipping: 0.5, fragile: 0,
      low: 0, med: 0.5, high: 1,
    };
    const computeMetrics = (name) => {
      const entries = orpdaSessions[name] || [];
      if (!entries.length) return null;
      const attn = [];
      const align = [];
      const fatigue = [];
      const driftInt = [];
      const driftTypes = {};
      const driftTopics = {};
      let shouldDriftTrue = 0;
      entries.forEach(e => {
        const ref = (e.orpda || {}).reflection || {};
        const drift = (e.orpda || {}).drift_decision || {};
        const ar = (e.orpda || {}).action_result || {};
        if (ref.attention_stability in modeMap) attn.push(modeMap[ref.attention_stability]);
        if (ref.plan_alignment in modeMap) align.push(modeMap[ref.plan_alignment]);
        if (ref.boredom_fatigue in modeMap) fatigue.push(modeMap[ref.boredom_fatigue]);
        const di = parseFloat(drift.drift_intensity ?? ar.drift_intensity ?? 0);
        if (Number.isFinite(di)) driftInt.push(di);
        const dt = drift.drift_type || ar.drift_type || "none";
        driftTypes[dt] = (driftTypes[dt] || 0) + 1;
        const topic = drift.drift_topic || ar.drift_topic || "";
        if (topic) driftTopics[topic] = (driftTopics[topic] || 0) + 1;
        if (drift.should_drift === true || ar.should_drift === true) shouldDriftTrue += 1;
      });
      const total = entries.length;
      const topTopics = Object.entries(driftTopics).sort((a,b) => b[1]-a[1]).slice(0,5).map(([t,c]) => t);
      // keywords from topics
      const kwCounts = {};
      Object.keys(driftTopics).forEach(t => {
        t.split(/[^A-Za-z]+/).forEach(w => {
          const w2 = w.toLowerCase();
          if (w2.length < 4) return;
          if (stopWords.has(w2)) return;
          kwCounts[w2] = (kwCounts[w2] || 0) + driftTopics[t];
        });
      });
      const topKeywords = Object.entries(kwCounts).sort((a,b) => b[1]-a[1]).slice(0,5).map(([w,c]) => w);
      return {
        attnAvg: avgScore(attn),
        alignAvg: avgScore(align),
        fatigueAvg: avgScore(fatigue),
        driftAvg: avgScore(driftInt),
        driftTypes,
        shouldDriftPct: total ? Math.round((shouldDriftTrue / total) * 100) : 0,
        topTopics,
        topKeywords,
      };
    };

    const gauge = (label, val, color) => {
      const pct = Math.max(0, Math.min(100, Math.round(val * 100)));
      return `<div class="metric-card">
        <div class="metric-gauge-label"><span>${label}</span><span>${pct}%</span></div>
        <div class="metric-gauge-track"><div class="metric-gauge-fill" style="width:${pct}%; background:${color};"></div></div>
      </div>`;
    };
    let selectedMinute = 6 * 60; // default to 06:00 on load
    const timeSlider = document.getElementById("time-slider");
    const timeLabel = document.getElementById("time-label");
    const timeMinus = document.getElementById("time-minus");
    const timePlus = document.getElementById("time-plus");
    const schedulesBody = document.getElementById("schedules-body");
    const biosBody = document.getElementById("bios-body");
    const schedulesToggle = document.getElementById("schedules-toggle");
    const biosToggle = document.getElementById("bios-toggle");
    const feedbackSection = document.getElementById("feedback-section");
    const feedbackBody = document.getElementById("feedback-body");
    const feedbackToggle = document.getElementById("feedback-toggle");
    const feedbackList = document.getElementById("feedback-list");
    const feedbackStatus = document.getElementById("feedback-status");
    const dateLabel = document.getElementById("date-label");
    const stateRow = document.getElementById("state-row");
    const metricsSection = document.getElementById("metrics-section");
    const metricsBody = document.getElementById("metrics-body");
    const yamlOverlay = document.getElementById("yaml-overlay");
    const yamlContent = document.getElementById("yaml-content");
    const yamlClose = document.getElementById("yaml-close");
    const layerDataByStage = {};
    const isScalar = (v) => v === null || v === undefined || ["string", "number", "boolean"].includes(typeof v);
    const toYAML = (val, indent = 0) => {
      const pad = "  ".repeat(indent);
      if (Array.isArray(val)) {
        if (!val.length) return `${pad}[]`;
        return val
          .map(item => {
            if (isScalar(item)) return `${pad}- ${item ?? ""}`;
            const child = toYAML(item, indent + 1);
            return `${pad}-\n${child}`;
          })
          .join("\n");
      }
      if (val && typeof val === "object") {
        const entries = Object.entries(val);
        if (!entries.length) return `${pad}{}`;
        return entries
          .map(([k, v]) => {
            if (isScalar(v)) return `${pad}${k}: ${v ?? ""}`;
            const child = toYAML(v, indent + 1);
            return `${pad}${k}:\n${child}`;
          })
          .join("\n");
      }
      return `${pad}${val ?? ""}`;
    };
    const setSectionState = (body, toggleEl, expand) => {
      if (!body) return;
      body.classList.toggle("collapsed", !expand);
      if (toggleEl) toggleEl.textContent = expand ? "Collapse" : "Expand";
    };
    const extractDate = (sched) => {
      const first = (sched && sched[0] && sched[0].datetime_start) || "";
      return first.split(" ")[0] || "--";
    };
    const updateDateLabel = () => {
      if (!dateLabel) return;
      let dateStr = "--";
      if (chosen.length > 0) {
        const sched = scheduleByName[chosen[0]] || [];
        dateStr = extractDate(sched);
      } else if (personas[0] && personas[0].schedule) {
        dateStr = extractDate(personas[0].schedule);
      }
      dateLabel.textContent = dateStr;
    };
    const currentLocationFor = (name, minute) => {
      const sched = scheduleByName[name] || [];
      const slot = sched.find(s => minute >= (s.start_time ?? 0) && minute < (s.end_time ?? 0));
      if (slot && slot.location) return slot.location;
      const route = guessRoute(name);
      return route[0] || "home";
    };
    const buildAssignmentsAt = (minute) => {
      if (chosen.length === 0) return {};
      const assignments = {};
      chosen.forEach(name => {
        const persona = personaByName[name];
        if (!persona) return;
        const loc = currentLocationFor(name, minute) || "home";
        const [parentRaw, childRaw] = loc.split(":");
        let cell = parentRaw || "home";
        if (!mapIds.has(cell)) cell = "outdoor";
        if (!assignments[cell]) assignments[cell] = [];
        assignments[cell].push({ name, child: childRaw || null });
      });
      return assignments;
    };

    function rebuildMapFromSelection() {
      const tree = {};
      const ensureParent = (parent) => {
        if (!tree[parent]) tree[parent] = new Set();
      };
      const addLoc = (loc) => {
        if (!loc) return;
        const [parentRaw, childRaw] = loc.split(":");
        const parent = parentRaw || "home";
        ensureParent(parent);
        if (childRaw) tree[parent].add(childRaw);
      };

      chosen.forEach(name => {
        (scheduleByName[name] || []).forEach(slot => addLoc(slot.location || "home"));
      });
      if (chosen.length === 0 && Object.keys(tree).length === 0) {
        ensureParent("home");
      }

      mapLayout = Object.keys(tree).map(parent => ({
        id: parent,
        label: parent.replace(/_/g, " "),
        children: Array.from(tree[parent] || []).map(ch => ({
          id: ch,
          label: (ch || "").replace(/_/g, " "),
        })),
      }));
      mapIds = new Set(mapLayout.map(c => c.id));
      buildMap();
      refreshMap();
    }

    function buildMap() {
      mapGrid.innerHTML = "";
      mapLayout.forEach(cell => {
        const div = document.createElement("div");
        div.className = "cell";
        div.dataset.cellId = cell.id;
        const children = (cell.children || []).map(child => {
          return `<div class="subcell" data-child-id="${cell.id}:${child.id}">
                    <div class="subcell-label">${child.label}</div>
                    <div class="token-tray"></div>
                  </div>`;
        }).join("");
        const childrenBlock = `<div class="child-grid">${children}</div>`;
        div.innerHTML = `<div class="cell-label">${cell.label}</div>${childrenBlock}<div class="token-tray"></div>`;
        mapGrid.appendChild(div);
      });
    }

    function placeTokens(assignments) {
      mapLayout.forEach(cell => {
        const target = mapGrid.querySelector(`[data-cell-id="${cell.id}"]`);
        if (!target) return;
        // clear existing tokens in both parent tray and child trays
        target.querySelectorAll(".token-tray").forEach(tr => tr.querySelectorAll(".token").forEach(t => t.remove()));
        const list = assignments[cell.id] || [];
        list.forEach((entry) => {
          const { name, child } = typeof entry === "string" ? { name: entry, child: null } : entry;
          const tok = document.createElement("div");
          tok.className = "token";
          tok.style.background = colorFor(name);
          const icon = faceMap[name] || emojiMap[name] || "üß©";
          tok.textContent = `${icon} ${name.split(" ")[0] || name}`;
          let tray = target.querySelector(".token-tray");
          if (child) {
            const childTray = target.querySelector(`[data-child-id="${cell.id}:${child}"] .token-tray`);
            if (childTray) tray = childTray;
          }
          (tray || target).appendChild(tok);
        });
      });
    }

    function refreshMap() {
      placeTokens(buildAssignmentsAt(selectedMinute));
      if (timeLabel) timeLabel.textContent = fmtTime(selectedMinute);
      if (timeSlider) timeSlider.value = selectedMinute;
      renderStateRow();
    }

    const guessRoute = (name) => {
      const persona = personas.find(x => x.name === name) || {};
      const text = (persona.raw_persona || "").toLowerCase();
      const route = [];
      const pushIf = (key, id) => { if (text.includes(key)) route.push(id); };
      pushIf("home", "home");
      pushIf("cafe", "Hobbs_Cafe");
      pushIf("hobbs", "Hobbs_Cafe");
      pushIf("market", "Willow_Market_and_Pharmacy");
      pushIf("pharmacy", "Willow_Market_and_Pharmacy");
      pushIf("college", "Oak_Hill_College");
      pushIf("park", "Johnson_Park");
      pushIf("studio", "art_studio");
      pushIf("writer", "writer_desk");
      pushIf("classroom", "Oak_Hill_College");
      if (route.length === 0) route.push("home", "office");
      return route.slice(0, 4);
    };

    function renderTown(message = "") {
      town.innerHTML = "";
      chosen.forEach(name => {
        const tile = document.createElement("div");
        tile.className = "tile";
        const prof = emojiMap[name] || "üß©";
        const m = metricsByName[name];
        const driftPct = m ? `${m.shouldDriftPct || 0}%` : "--";
        tile.innerHTML = `
          <div class="emoji" style="font-size:42px; margin-top:4px;">${prof}</div>
          <div style="font-size:14px; font-weight:800; margin-top:10px;">${name}</div>
          <div style="font-size:12px; margin-top:12px; color:#9fb3c8;">Drift: ${driftPct}</div>
        `;
        tile.onclick = () => {
          if (simLocked) return;
          const idx = chosen.indexOf(name);
          if (idx >= 0) {
            chosen.splice(idx, 1);
            renderTown();
            renderMetricsPanel();
          }
        };
        town.appendChild(tile);
      });
      // add empty placeholders up to 1 slot
      for (let i = chosen.length; i < 1; i++) {
        const ph = document.createElement("div");
        ph.className = "tile placeholder";
        ph.innerHTML = `<div style="font-size:12px;">Empty slot</div>`;
        town.appendChild(ph);
      }
      if (message) {
        townLabel.textContent = message;
      } else {
        townLabel.textContent = chosen.length < 1 ? "Select one persona" : "Ready to simulate";
      }
      rebuildMapFromSelection();
      renderSchedules();
      renderStateRow();
      renderBios();
      renderMetricsPanel();
      updateDateLabel();
    }

    function renderSchedules() {
      if (!schedulesGrid) return;
      if (chosen.length === 0) {
        schedulesGrid.innerHTML = `<div class="small-muted">Select personas to view their schedules.</div>`;
        return;
      }
      schedulesGrid.innerHTML = chosen.map(name => {
        const sched = scheduleByName[name] || [];
        if (!sched.length) {
          return `<div class="section-card"><div class="chip">${emojiMap[name] || "üß©"} ${name}</div><div class="small-muted">No schedule available.</div></div>`;
        }
        const fmtRange = (s) => {
          const start = s.start_time ?? 0;
          const end = s.end_time ?? (start + (s.duration_min || 0));
          const pad = (n) => String(n).padStart(2, "0");
          const hhmm = (m) => `${pad(Math.floor(m / 60))}:${pad(m % 60)}`;
          return `${hhmm(start)}-${hhmm(end)}`;
        };
        const rows = sched.map(s => {
          const t = fmtRange(s);
          return `<div class="mono" style="margin:2px 0;">${t} ‚Äî ${s.location || "home"} ‚Äî ${s.action || ""}${s.topic ? " ‚Äî " + s.topic : ""}</div>`;
        }).join("");
        return `<div class="section-card"><div class="chip">${emojiMap[name] || "üß©"} ${name} schedule</div>${rows}</div>`;
      }).join("");
    }

    const currentSlotFor = (name, minute) => {
      const sched = scheduleByName[name] || [];
      return sched.find(s => minute >= (s.start_time ?? 0) && minute < (s.end_time ?? 0));
    };

    function actualStateFor(name, minute, dataset) {
      const entries = (dataset && dataset[name]) || [];
      let best = null;
      let bestDelta = Infinity;
      entries.forEach(e => {
        const orpda = e.orpda || {};
        const ar = orpda.action_result || {};
        const obs = orpda.observation || {};
        const ref = orpda.reflection || {};
        const plan = orpda.plan || {};
        const drift = orpda.drift_decision || {};
        const t = minsFromDt(ar.datetime_start || e.sim_time);
        if (t === null) return;
        const delta = Math.abs(minute - t);
        if (delta < bestDelta) {
          bestDelta = delta;
          best = {
            time: ar.datetime_start || e.sim_time,
            location: ar.location || "",
            action: ar.action || "",
            summary: ar.state_summary || "",
            observation: obs,
            reflection: ref,
            plan: plan,
            drift: drift,
            action_result: ar,
          };
        }
      });
      // discard if too far from the requested minute (e.g., stale data)
      if (!best || bestDelta > 15) return null; // >15 minutes away -> treat as no data
      return best;
    }

    function renderStateRow() {
      if (!stateGrid) return;
      Object.keys(layerDataByStage).forEach(k => delete layerDataByStage[k]);
      const restartVisible = restartBtn && window.getComputedStyle(restartBtn).display !== "none";
      if (!restartVisible) {
        if (stateRow) stateRow.style.display = "none";
      }
      if (chosen.length === 0) {
        stateGrid.innerHTML = `<div class="small-muted">Select personas to view their current state.</div>`;
        return;
      }
      if (stateRow) {
        if (restartVisible && !prevRestartVisible) {
          stateCollapsed = false; // expand by default when restart becomes visible
        }
        stateRow.style.display = restartVisible ? "block" : "none";
        attachStateToggle();
        const bodies = stateRow.querySelectorAll(".state-grid");
        bodies.forEach(b => b.style.display = (restartVisible && !stateCollapsed) ? "flex" : "none");
        stateToggle.style.display = restartVisible ? "flex" : "none";
        const label = stateToggle.querySelector(".section-toggle");
        if (label) label.textContent = stateCollapsed ? "Expand" : "Collapse";
      }
      prevRestartVisible = restartVisible;
      const rows = ["Scheduled", "Observe", "Reflect", "Plan", "Drift", "Action"];
      const hasData = (dataset, name) => Array.isArray(dataset?.[name]) && dataset[name].length > 0;
      const buildPersona = (name, dataset, variantTitle = "ORPDA (with drift)", variantClass = "") => {
        const actual = actualStateFor(name, selectedMinute, dataset);
        const slot = currentSlotFor(name, selectedMinute);
        const loc = (actual && actual.location) || slot?.location || "home";
        const action = (actual && actual.action) || slot?.action || "idle";
        const env = (actual && actual.summary) || slot?.environment_description || "No distractors noted.";
        const start = slot?.start_time ?? 0;
        const end = slot?.end_time ?? (start + (slot?.duration_min || 0));
        const pad = (n) => String(n).padStart(2, "0");
        const hhmm = (m) => `${pad(Math.floor(m / 60))}:${pad(m % 60)}`;
        const scheduleRange = `${slot?.datetime_start || hhmm(start)}-${slot?.datetime_end || hhmm(end)}`;
        const timeRange = (actual && actual.time) || scheduleRange;
        return {
          name,
          slot,
          loc,
          action,
          env,
          scheduleRange,
          timeRange,
          obs: actual?.observation || {},
          ref: actual?.reflection || {},
          plan: actual?.plan || {},
          drift: actual?.drift || {},
          act: actual?.action_result || {},
          variantTitle,
          variantClass,
        };
      };

      const perPersona = [];
      chosen.forEach(name => {
        const hasOrpa = hasData(orpaSessions, name);
        const hasOrpda = hasData(orpdaSessions, name);
        if (chosen.length === 1) {
          if (hasOrpa) perPersona.push(buildPersona(name, orpaSessions, "ORPA (baseline)", "orpa-cell"));
          if (hasOrpda) perPersona.push(buildPersona(name, orpdaSessions, "ORPDA (with drift)", "orpda-cell"));
          if (!hasOrpa && !hasOrpda) perPersona.push(buildPersona(name, {}, "No session data", ""));
        } else {
          if (hasOrpda) perPersona.push(buildPersona(name, orpdaSessions, "ORPDA (with drift)", "orpda-cell"));
        }
      });
      const colCount = perPersona.length * 2 + (showEval ? 1 : 0);
      const isEmpty = (obj) => !obj || (Object.keys(obj).length === 0);
      const hasContent = (obj) => {
        if (!obj) return false;
        return Object.keys(obj).some(k => {
          const v = obj[k];
          if (v === null || v === undefined) return false;
          if (typeof v === "string") return v.trim() !== "";
          return true;
        });
      };
      const makeCell = (title, lines, isDistract = false, variantClass = "") => {
        const content = lines.map(l => `<div class="line">${l}</div>`).join("");
        return `<div class="row-box ${isDistract ? "distract" : ""} ${variantClass}"><div class="row-title ${isDistract ? "distract" : ""}">${title}</div>${content}</div>`;
      };
      let headerRow = "";
      if (perPersona.length > 0) {
        const headerCells = [];
        perPersona.forEach((p, idx) => {
          headerCells.push(`<div class="header-cell ${p.variantClass}"><span class="header-badge ${p.variantClass}">${p.variantTitle || ""}</span></div>`);
          headerCells.push(`<div class="header-cell ${p.variantClass}"></div>`);
          if (idx === 0 && showEval) headerCells.push(`<div class="header-cell"></div>`);
        });
        headerRow = `<div class="row-grid" style="grid-template-columns: repeat(${colCount}, minmax(220px, 1fr));">${headerCells.join("")}</div>`;
      }
      const actionLine = (act) => act ? `<span class="action-badge">${actionEmoji(act)}</span><span class="label">Action:</span> <strong>${act}</strong>` : "";
      const feedbackCell = (stage) => {
        return `<div class="row-box feedback-box" data-stage="${stage}">
          <div class="row-title">Feedback</div>
          <div class="line"><button class="view-yaml" data-stage="${stage}">View YAML</button></div>
          <div class="line">
            <span class="label">Verdict:</span>
            <select class="feedback-verdict" data-stage="${stage}">
              <option value="">Select</option>
              <option value="pass">Pass</option>
              <option value="fail">Fail</option>
              <option value="uncertain">Uncertain</option>
            </select>
          </div>
          <div class="line">
            <textarea class="feedback-notes" data-stage="${stage}" placeholder="Add notes or reason codes..."></textarea>
          </div>
          <div class="actions">
            <button class="save-feedback" data-stage="${stage}">Save</button>
            <span class="small-muted" id="fb-status-${stage.replace(/\s+/g,'-')}"></span>
          </div>
        </div>`;
      };
      const cellsFor = (p, stage) => {
        switch (stage) {
          case "Scheduled":
            return [
              makeCell(
                "Scheduled",
                [
                  `<span class="label">Time:</span> ${p.scheduleRange}`,
                  `<span class="label">Location:</span> ${p.slot?.location || p.loc}`,
                  actionLine(p.slot?.action || p.action),
                ],
                false,
                p.variantClass
              ),
              makeCell("Distractions", [p.slot?.environment_description || p.env], true, p.variantClass),
            ];
          case "Observe":
            if (!hasContent(p.obs)) {
              return [
                makeCell("Observe", [`<span class="no-data">No data</span>`], false, p.variantClass),
                makeCell("", [], true, p.variantClass),
              ];
            }
            return [
              makeCell(
                "Observe",
                [
                  `<span class="label">Time:</span> ${p.obs.datetime_start || p.timeRange}`,
                  `<span class="label">Location:</span> ${p.obs.location || p.loc}`,
                  actionLine(p.obs.action || ""),
                  `<span class="label">Summary:</span> ${p.obs.state_summary || ""}`,
                ],
                false,
                p.variantClass
              ),
              makeCell("", [], true, p.variantClass),
            ];
          case "Reflect":
            if (!hasContent(p.ref)) {
              return [
                makeCell("Reflect", [`<span class="no-data">No data</span>`], false, p.variantClass),
                makeCell("", [], true, p.variantClass),
              ];
            }
            return [
              makeCell(
                "Reflect",
                [
                  `<span class="label">Alignment:</span> ${p.ref.plan_alignment || ""}`,
                  `<span class="label">Attention:</span> ${p.ref.attention_stability || ""}`,
                  `<span class="label">Boaredome fatigue:</span> ${p.ref.boredom_fatigue || ""}`,
                  `<span class="label">Rumination:</span> ${p.ref.rumination_theme || "none"}`,
                  `<span class="label">Attiontianal pressure:</span> ${p.ref.attentional_pressure_factors || "none"}`,
                  `<span class="label">Emotional residue:</span> ${p.ref.emotional_residue || "none"}`,
                  `<span class="label">Summary:</span> ${p.ref.state_summary || ""}`,
                  `<span class="label">Reasoning:</span> ${p.ref.reasoning || ""}`,
                ],
                false,
                p.variantClass
              ),
              makeCell("", [
                  `${p.ref.plan_alignment || ""}, ${p.ref.attention_stability || ""}, ${p.ref.meta_rule || ""}`,
                  `<div style="height:6px;"></div>`,
                  
                  ], true, p.variantClass),
            ];
          case "Plan":
            if (!hasContent(p.plan)) {
              return [
                makeCell("Plan", [`<span class="no-data">No data</span>`], false, p.variantClass),
                makeCell("", [], true, p.variantClass),
              ];
            }
            return [
              makeCell(
                "Plan",
                [
                  `<span class="label">Time:</span> ${p.plan.datetime_start || ""}`,
                  `<span class="label">Location:</span> ${p.plan.location || ""}`,
                  actionLine(p.plan.action || ""),
                  `<span class="label">Topic:</span> ${p.plan.topic || ""}`,
                ],
                false,
                p.variantClass
              ),
              makeCell("", [
                  `<span class=label>[</span>${p.plan.topic || ""}<span class=label>]</span>`,
                  `<div style="height:6px;"></div>`,
                  `${p.plan.state_summary ?? ""}`,
                  ], true, p.variantClass),
            ];
          case "Drift":
            if (!hasContent(p.drift)) {
              return [
                makeCell("Drift", [`<span class="no-data">No data</span>`], false, p.variantClass),
                makeCell("", [], true, p.variantClass),
              ];
            }
            return [
              makeCell(
                "Drift",
                [
                  `<span class="label">Should drift?</span> ${p.drift.should_drift ?? ""}`,
                  `<span class="label">Drift type:</span> ${p.drift.drift_type ?? ""}`,
                  `<span class="label">Drift intensity:</span> ${p.drift.drift_intensity ?? ""}`,
                  <!-- `<span class="label">DMN mode:</span> ${p.drift.dmn_mode || ""}`, -->
                  `<span class="label">Topic:</span> ${p.drift.drift_topic || ""}`,
                  `<span class="label">Justification:</span> ${p.drift.justification || ""}`,
                  `<span class="label">Potential recovery:</span> ${p.drift.potential_recovery || ""}`,

                ],
                false,
                p.variantClass
              ),
              makeCell(
                "",
                [
                  <!-- `<span class="label">DMN mode: ${p.drift.dmn_mode || ""}</span>`, -->
                  `${p.drift.drift_type || ""}`,
                  `${p.drift.drift_intensity ?? ""}`,
                  `<span class="label">[</span>${p.drift.drift_topic ?? ""}<span class="label">]</span>`,
                  `<div style="height:6px;"></div>`,
                  `${p.drift.justification ?? ""}`,

                  ],
                true,
                p.variantClass
              ),
              
            ];
          case "Action":
            if (!hasContent(p.act)) {
              return [
                makeCell("Action", [`<span class="no-data">No data</span>`], false, p.variantClass),
                makeCell("Results", [`<span class="no-data">No data</span>`], true, p.variantClass),
              ];
            }
            return [
              makeCell(
                "Action",
                [
                  `<span class="label">Time:</span> ${p.act.datetime_start || p.timeRange}`,
                  `<span class="label">Location:</span> ${p.act.location || p.loc}`,
                  <!-- `<span class="label">Drift type:</span> ${p.act.drift_type || ""}`, -->
                  <!-- `<span class="label">Drift topic:</span> ${p.act.drift_topic || ""}`, -->
                  actionLine(p.act.action || p.action),
                  `<span class="label">Topic:</span> ${p.act.topic || ""}`,
                  `<span class="label">Summary:</span> ${p.act.state_summary || ""}`,
                ],
                false,
                p.variantClass
              ),
              makeCell("Results", [
                  `<span class="label">[</span>${p.act.topic ?? ""}<span class="label">]</span>`,
                  `<div style="height:6px;"></div>`,
                  `${p.act.state_summary ?? ""}`,

                  <!-- p.env -->
              ], true, p.variantClass),
            ];
          default:
            return [makeCell(stage, []), makeCell("Distractions", [], true)];
        }
      };

      const htmlRows = [];
      rows.forEach(stage => {
        const gridCells = [];
        const snapshot = perPersona.map(p => ({
          name: p.name,
          scheduleRange: p.scheduleRange,
          timeRange: p.timeRange,
          slot: p.slot,
          observation: p.obs,
          reflection: p.ref,
          plan: p.plan,
          drift_decision: p.drift,
          action_result: p.act,
        }));
        layerDataByStage[stage] = {
          stage,
          minute: fmtTime(selectedMinute),
          session_date: dateLabel ? dateLabel.textContent : "",
          personas: snapshot,
        };
        perPersona.forEach((p, idx) => {
          const [info, distract] = cellsFor(p, stage);
          gridCells.push(info);
          gridCells.push(distract);
          if (idx === 0 && showEval) {
            gridCells.push(feedbackCell(stage));
          }
        });
        if (perPersona.length === 0 && showEval) {
          gridCells.push(feedbackCell(stage));
        }
        htmlRows.push(`<div class="row-grid" style="grid-template-columns: repeat(${colCount}, minmax(220px, 1fr));">${gridCells.join("")}</div>`);
      });

      stateGrid.innerHTML = `${headerRow}${htmlRows.join("")}`;
      bindFeedbackHandlers();
    }

    function openYaml(stage) {
      const data = layerDataByStage[stage];
      if (!data) {
        alert("No YAML available for this layer yet.");
        return;
      }
      if (yamlContent) yamlContent.textContent = toYAML(data);
      if (yamlOverlay) yamlOverlay.style.display = "flex";
    }

    function bindFeedbackHandlers() {
      document.querySelectorAll(".view-yaml").forEach(btn => {
        btn.onclick = () => openYaml(btn.dataset.stage);
      });
      document.querySelectorAll(".save-feedback").forEach(btn => {
        btn.onclick = () => {
          const stage = btn.dataset.stage;
          const verdictEl = document.querySelector(`.feedback-verdict[data-stage="${stage}"]`);
          const notesEl = document.querySelector(`.feedback-notes[data-stage="${stage}"]`);
          const statusEl = document.getElementById(`fb-status-${stage.replace(/\s+/g,'-')}`);
          const verdict = verdictEl ? verdictEl.value : "";
          const comment = notesEl ? notesEl.value : "";
          if (!verdict) {
            if (statusEl) statusEl.textContent = "Select a verdict.";
            return;
          }
          if (statusEl) statusEl.textContent = "Saving...";
          const payload = {
            stage,
            verdict,
            comment,
            personas: chosen,
            minute: fmtTime(selectedMinute),
            session_date: dateLabel ? dateLabel.textContent : "",
            schedule_range: (layerDataByStage[stage]?.personas || [])[0]?.scheduleRange || "",
          };
          fetch("/feedback", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          })
            .then(r => r.json())
            .then(data => {
              if (data.error) throw new Error(data.error);
              if (statusEl) statusEl.textContent = "Saved.";
              loadFeedback();
            })
            .catch(err => {
              console.error(err);
              if (statusEl) statusEl.textContent = "Save failed.";
            });
        };
      });
    }

    function renderBios() {
      if (!biosGrid) return;
      if (chosen.length === 0) {
        biosGrid.innerHTML = `<div class="small-muted">Select personas to view their bios.</div>`;
        return;
      }
      biosGrid.innerHTML = chosen.map(name => {
        const persona = personas.find(p => p.name === name) || {};
        const bio = persona.raw_persona || "No bio available.";
        return `<div class="section-card"><div class="chip">${emojiMap[name] || "üß©"} ${name} bio</div><div style="white-space:pre-wrap; line-height:1.5; margin-top:6px;">${bio}</div></div>`;
      }).join("");
    }

    function renderFeedbackList(rows) {
      if (!feedbackList || !feedbackStatus) return;
      if (!rows || rows.length === 0) {
        feedbackStatus.textContent = "No feedback yet.";
        feedbackList.innerHTML = "";
        return;
      }
      feedbackStatus.textContent = `${rows.length} feedback item${rows.length === 1 ? "" : "s"}.`;
      const cards = rows.map(r => {
        const personas = (r.personas || []).join(", ");
        return `
          <div class="section-card">
            <h4>${r.stage || "Unknown"} ‚Ä¢ ${r.verdict || ""}</h4>
            <div class="small-muted">${r.ts_utc || ""}</div>
            <div class="mono" style="margin:4px 0;">${personas || "No personas"}</div>
            <div class="small-muted">Time: ${r.session_date || ""} ${r.minute || ""} ${r.schedule_range ? "(" + r.schedule_range + ")" : ""}</div>
            <div style="margin:6px 0;">${r.comment || ""}</div>
          </div>
        `;
      }).join("");
      feedbackList.innerHTML = cards;
    }

    function loadFeedback() {
      if (!feedbackStatus) return;
      feedbackStatus.textContent = "Loading feedback...";
      fetch("/eval")
        .then(r => r.json())
        .then(data => {
          renderFeedbackList(data.feedback || []);
        })
        .catch(() => {
          feedbackStatus.textContent = "Failed to load feedback.";
        });
    }

    personas.forEach(p => {
      metricsByName[p.name] = computeMetrics(p.name);
      const card = document.createElement("div");
      card.className = "card";
      const prof = emojiMap[p.name] || "üß©";
      const m = metricsByName[p.name];
      const driftBadge = m ? `<div class="muted" style="font-size:11px; margin-top:8px;">Drift: ${m.shouldDriftPct || 0}%</div>` : `<div class="muted" style="font-size:11px; margin-top:8px;">Drift: --</div>`;
      card.innerHTML = `
        <div class="emoji">${prof}</div>
        <div class="name">${p.name}</div>
        ${driftBadge}
      `;
      card.onclick = () => {
        if (simLocked) return;
        const idx = chosen.indexOf(p.name);
        if (idx >= 0) {
          chosen.splice(idx, 1);
        } else {
          chosen.splice(0, chosen.length);
          chosen.push(p.name);
        }
        renderTown();
      };
      grid.appendChild(card);
    });
    const renderMetricsPanel = () => {
      if (!metricsSection || !metricsBody) return;
      if (chosen.length === 0) {
        metricsSection.style.display = "none";
        return;
      }
      const m = metricsByName[chosen[0]];
      if (!m) {
        metricsSection.style.display = "none";
        return;
      }
      metricsSection.style.display = "block";
      const driftTypeText = Object.entries(m.driftTypes || {}).map(([k,v]) => `${k}: ${v}`).join(" | ") || "none";
      const keywords = (m.topKeywords || []).map(k => `<span class="metric-badge">${k}</span>`).join("") || "<span class=\"metric-badge\">none</span>";
      metricsBody.innerHTML = `
        <div class="metrics-grid">
          ${gauge("Attention", m.attnAvg, "#2dd4bf")}
          ${gauge("Alignment", m.alignAvg, "#60a5fa")}
          ${gauge("Fatigue", m.fatigueAvg, "#f59e0b")}
          ${gauge("Drift intensity", m.driftAvg, "#f97316")}
          ${gauge("Should drift", m.shouldDriftPct/100, "#a78bfa")}
        </div>
        <div class="metrics-row">
          <span class="metric-badge"><span class="metric-label">Drift types:</span> ${driftTypeText}</span>
        </div>
        <div class="metrics-row" style="gap:10px;">
          <span class="metric-label inline" style="margin-top:2px;">Top drift keywords:</span>
          <span class="chipline">${keywords}</span>
        </div>
      `;
    };
    // initial placeholders and base map
    renderTown();
    rebuildMapFromSelection();
    refreshMap();
    renderMetricsPanel();
    // initial collapsed defaults
    setSectionState(schedulesBody, schedulesToggle, false);
    setSectionState(biosBody, biosToggle, true);
    if (showEval) setSectionState(feedbackBody, feedbackToggle, true);
    if (schedulesSection) schedulesSection.style.display = "none";
    if (stateRow) stateRow.style.display = "none";
    const stateToggle = document.createElement("div");
    stateToggle.className = "section-header";
    stateToggle.style.justifyContent = "space-between";
    stateToggle.style.alignItems = "center";
    stateToggle.style.margin = "0";
    stateToggle.innerHTML = `<div class="section-title" style="color:#0f172a;">Current state</div><div class="section-toggle">Expand</div>`;
    let stateCollapsed = true;
    let prevRestartVisible = false;
    const attachStateToggle = () => {
      if (!stateRow || stateToggle.parentElement === stateRow) return;
      stateRow.prepend(stateToggle);
      stateToggle.onclick = () => {
        stateCollapsed = !stateCollapsed;
        const bodies = stateRow.querySelectorAll(".state-grid");
        bodies.forEach(b => b.style.display = stateCollapsed ? "none" : "flex");
        const label = stateToggle.querySelector(".section-toggle");
        if (label) label.textContent = stateCollapsed ? "Expand" : "Collapse";
      };
    };
    renderStateRow();
    const syncSectionsVisibility = () => {
      const restartVisible = restartBtn && restartBtn.style.display !== "none";
      if (schedulesSection) {
        schedulesSection.style.display = restartVisible ? "block" : "none";
        if (!restartVisible) setSectionState(schedulesBody, schedulesToggle, false);
      }
      setSectionState(biosBody, biosToggle, !restartVisible ? true : false);
      if (feedbackSection) feedbackSection.style.display = showEval ? "block" : "none";
      if (showEval) setSectionState(feedbackBody, feedbackToggle, true);
      updateDateLabel();
    };
    syncSectionsVisibility();
    if (showEval) loadFeedback();
    setInterval(refreshMap, 1000 * 30); // update positions every 30s

    // Collapsible sections
    document.querySelectorAll(".section-header").forEach(head => {
      head.addEventListener("click", () => {
        const targetId = head.dataset.target;
        const body = document.getElementById(targetId);
        if (!body) return;
        const toggleLabel = head.querySelector(".section-toggle");
        const expand = body.classList.contains("collapsed");
        setSectionState(body, toggleLabel, expand);
      });
    });
    if (yamlClose) yamlClose.onclick = () => { if (yamlOverlay) yamlOverlay.style.display = "none"; };
    if (yamlOverlay) {
      yamlOverlay.addEventListener("click", (e) => {
        if (e.target === yamlOverlay) yamlOverlay.style.display = "none";
      });
    }

    // Time controls wiring
    if (timeSlider) {
      timeSlider.value = selectedMinute;
      timeSlider.addEventListener("input", (e) => {
        selectedMinute = clampMinute(parseInt(e.target.value || "0", 10) || 0);
        refreshMap();
      });
    }
    const shiftBy = (delta) => {
      selectedMinute = clampMinute(selectedMinute + delta);
      refreshMap();
    };
    if (timeMinus) timeMinus.onclick = () => shiftBy(-15);
    if (timePlus) timePlus.onclick = () => shiftBy(15);

      simBtn.onclick = () => {
        if (chosen.length < 1) {
          alert("Select a persona to simulate.");
          return;
        }
      const [a] = chosen; // only one persona
      floorTop.classList.add("faded");
      floorBottom.classList.add("faded");
      grid.classList.add("hidden");
      grid.style.height = "0px";
      grid.style.opacity = "0";
      grid.style.pointerEvents = "none";
      simBtn.style.display = "none";
      restartBtn.style.display = "inline-block";
      syncSectionsVisibility();
      setSectionState(schedulesBody, schedulesToggle, false);
      if (floorplanMap) floorplanMap.style.display = "block";
      townLabel.textContent = "Welcome to Driftville! - where mind drifts";
      if (town) town.style.display = "none";
      town.style.minHeight = "120px";
      town.style.maxHeight = "120px";
      simLocked = true;
      stateCollapsed = false; // show current state when restart becomes visible
      renderStateRow();
      fetch("/simulate_conversation", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ agent1: a, agent2: a })
      })
      .then(r => r.json())
      .then(data => {
        console.log("Simulation result:", data);
      })
      .catch(() => { console.warn("Simulation failed."); })
      .finally(() => {
        floorTop.classList.remove("faded");
        floorBottom.classList.remove("faded");
        // keep grid collapsed until restart
      });
    };

    restartBtn.onclick = () => {
      // simple reload/reset of selections and UI
      chosen.splice(0, chosen.length);
      renderTown();
      restartBtn.style.display = "none";
      if (floorplanMap) floorplanMap.style.display = "none";
      if (town) town.style.display = "flex";
      grid.classList.remove("hidden");
      grid.style.height = "";
      grid.style.opacity = "1";
      grid.style.pointerEvents = "auto";
      simBtn.style.display = "inline-block";
      floorTop.classList.remove("faded");
      floorBottom.classList.remove("faded");
      townLabel.textContent = chosen.length < 1 ? "Select one persona" : "Ready to simulate";
      town.style.minHeight = "260px";
      town.style.maxHeight = "260px";
      simLocked = false;
      stateCollapsed = true;
      renderStateRow();
      syncSectionsVisibility();
    };
    } catch (err) { showError(err); }
    })();
  </script>
</body>
</html>
